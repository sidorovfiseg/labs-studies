# Требования

1. Управление банковскими счетами:
    - Возможность создания и закрытия банковских счетов
    - Просмотр баланс и истории операции по счетам
    - Возможность установки лимитов и ограничений на счета

2. Управление картами:
    - Привязка карт к банковским счетам
    - Возможность заказа, активации и блокировки карт
    - Просмотр информации о картах и их статусе
3. Различные валюты:
    - Поддержка различных валют и их конвертация
    - Возможность отображения баланса и проведения операции в разных валютах
4. Денежные и валютные операции:
    - Переводы между счетами и картами
    - Платежи и переводы на другие банковские счета
    - Обмен валюты и конвертация средств
5. Безопасность и аутентификация:
    - Защита пользовательской информации и данных
    - Аутентификация пользователя при доступе к системе
    - Использование шифрования для защиты конфиденциальных данных 

# 2 пункт
Реализовать доступ к банковскому API через http-сервер: передать необходимые поля и возвращать
ответ в формате JSON

По хорошему оставить доступ через командную строку

Идеально все эндпоинты (http-методы и URI) сделать в соответствии с REST API

# 3 пункт 
- Реализовать первые два требования банковской системы
- Выложить на github/gitlab, ссылку добавить в таблицу на диске, где хранятся все материалы
- Отрефачить код в соответствии с архитектурой, которую мы разбирали на паре 
(разделить на пакеты/слои, внедрение зависимостей, репозиторий).
- Разделение логики на слои обязательно
- (Дополнительно) Добавить поддержку нескольких видов карт (например дебетовая, кредитная), 
которые будут отличаться по структуре (потренироваться работать с интерфейсами и перечислениями)

# 4 пункт. Внедрить аутентификацию в банковскую систему:
- Регистрация пользователя
- Принимать логин (почта или просто username) и пароль
- Сохранять эти данные в хранилище (можно просто в map)
- Возвращать jwt-токен с идентификатором пользоватля в payload
- Login(то же самое, что и регистрация, только без сохранения)
- По логину и паролю проверять существование пользователя в системе
- Возвращать jwt-токен с идентификатором пользователя в payload
- Хотя бы один из эндпоинтов (лучше все) должен работать с jwt-токеном
  (достаем из заголовка Authorization). Например:
- Возвращать только тот счет/карты, владельцем которого является
пользователь с идентификатором из токена
- Создавать счет/карту конкретного пользователя. Только идентификатор
пользователя передаем через токен

# Задача 1. Авторизация и Регистрация (дедлайн - 4 декабря 2023)
Реализовать HTTP-сервер банковской системы в соответствие с REST API

Данные сохранять в базу данных

Для каждой ошибке необходимо выбрать наиболее подходящий HTTP код.

Архитектура

Сценарий использования

1. Регистрация (создание) пользователя (POST /api/users)
 - Клиент передает ___логин (строка)___ и ___пароль (строка)___
 - Проверяем, что логин уникальный в рамках системы. Вернуть ошибку в
 случае существования пользователя с таким логином
 - Сохраняем в базу его ___идентификатор (uuid), имя___ и ___хеш пароля___
 - Клиент возвращает JWT токен с ___идентификатором___ пользователя. Время жизни токена выставляем в рамках пары часов
2. Получение токена входа (POST /api/tokens)
- Клиент передает ___логин (строка)___ и ___пароль (строка)___
- В системе ищется пользователь с таким логином
- Если пользователь не найден, возвращаем ошибку
- Сравниваем пароль найденного пользователя с переданным клиентом. В случае
неравенства вернуть ошибку
- Клиент возвращает JWT токен с ___идентификатором пользователя. Время 
жизни токена выставляем в рамках пары часов

# Задача 2. Создание и получение счетов (дедлайн - 11 декабря 2023)
В нашей банковской системе у пользователя может быть несколько счетов
с ___разным___ названием, которые пользователь может ___создавать___
и ___просматривать___

Сценарии использования:
1. Создание счета (POST /api/accounts)
- Клиент передает ___название___ счета вместе с jwt-токеном в заголовке
___Authorization___
- Проверяем, что у ___пользователя___ не существует ___счета___ с таким
названием. Возвращаем ошибку, если счет существует
- Сохраняем ___счет пользователя___ с ___названием и идентификатором пользователя___
- В ответ возвращаем ___созданный___ счет
2. Получение счетов пользователя (GET /api/accounts)
- Клиент jwt-токен в заголовке ___Authorization___ вместе с опциональным
query параметрами (фильтр)
   - name - название счета
   - itemsPerPage - количество элементов
   - page - страница пагинации
- Достаем из базы данных все счета __текущего пользователя___, 
удовлетворяющие фильтрам
   - name - фильтрует по вхождению строки (регистронезависимо) в 
      название счета (ILIKE в sql). Если пустой, то фильтр не применяется
   - itemsPerPage - берет определенное количество элементов на странице
     (LIMIT в sql). Если пустой (0 или меньше 0), то берется значение 1
   - page - берет определенную страницу (OFFSET в sql). Если пустой (0 или
  меньше 0), то берется значение 1
- В ответе возвращаем объект с полем items, в котором содержится список
найденных счетов

Достаем ___идентификатор___ пользователя из заголовка Authorization в 
отдельном ___middleware___. В обработчик из middleware передаем идентификатор
в ___контексте___.

# Задача 3. Пополнение и снятие денег с счета. Работа с транзакцией (дедлайн - 18 декабря 2023)


# Задача 4. Кодогенератор. Создание DI-контейнера (дедлайн - 25 декабря 2023)